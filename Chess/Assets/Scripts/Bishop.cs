//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Bishop : ChessPiece{

    public override BoardSpace[] GetAvailableSpaces()
    {
        List<BoardSpace> availableSpaces = new List<BoardSpace>();
        availableSpaces.AddRange(GetAvailableInDirection(SpaceDirection.FrontLeft));
        availableSpaces.AddRange(GetAvailableInDirection(SpaceDirection.FrontRight));
        availableSpaces.AddRange(GetAvailableInDirection(SpaceDirection.BackLeft));
        availableSpaces.AddRange(GetAvailableInDirection(SpaceDirection.BackRight));

        //foreach (SpaceDirection direction in Enum.GetValues(typeof(SpaceDirection)) { }

        //Debug.Log (activeSpace.getSpace(SpaceDirection.Front,PieceColor));
        /*
        List<BoardSpace> possibleSpaces = new List<BoardSpace>();
        BoardSpace[] Diagonals = gameManager.Board.getDiagonals(currentSpace);
        foreach (BoardSpace space in Diagonals) {
            possibleSpaces.Add(space);
        }
         */
        return availableSpaces.ToArray();
    }

    private List<BoardSpace> GetAvailableInDirection(SpaceDirection direction)
    {
        List<BoardSpace> availableSpaces = new List<BoardSpace>();
        BoardSpace checkSpace = currentSpace;
        while (gameManager.Board.testAdjacentSpace(ref checkSpace, direction, PieceColor))
        {
            availableSpaces.Add(checkSpace);
        }
        ChessPiece blockingPiece = (availableSpaces.Count > 0) ? availableSpaces[availableSpaces.Count - 1].OccupyingPiece : null;
        if (blockingPiece != null && blockingPiece.PieceColor == PieceColor)
        {
            availableSpaces.RemoveAt(availableSpaces.Count - 1);
        }
        return availableSpaces;
    }

}


